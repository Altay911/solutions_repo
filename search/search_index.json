{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"PROBLEM 1 Motivation Investigating the Range as a Function of the Angle of Projection Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The basic idea is straightforward: analyze how the range of a projectile depends on its angle of projection . Yet, beneath this simplicity lies a complex and versatile framework. What makes this topic compelling is the number of free parameters involved\u2014such as initial velocity , gravitational acceleration , and launch height . These parameters allow for a diverse set of solutions that describe phenomena ranging from the arc of a soccer ball to the trajectory of a rocket. 1. Theoretical Foundation We start with the fundamental equations of motion under constant acceleration due to gravity, assuming no air resistance. Equations of Motion Let: - \\( v_0 \\) : Initial velocity - \\( \\theta \\) : Angle of projection - \\( g \\) : Acceleration due to gravity (typically \\( 9.81 \\, \\text{m/s}^2 \\) ) - \\( R \\) : Horizontal range Decomposing the motion: Horizontal component: [ v_{x} = v_0 \\cos(\\theta) ] Vertical component: [ v_{y} = v_0 \\sin(\\theta) ] Time of flight \\( T \\) (for level ground): \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Range is then: \\[ R(\\theta) = v_{x} \\cdot T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 2. Analysis of the Range Effect of Angle on Range The range is maximized when \\( \\sin(2\\theta) \\) is maximized. Max value of \\( \\sin(2\\theta) \\) is 1 when \\( 2\\theta = 90^\\circ \\) \u2192 \\( \\theta = 45^\\circ \\) Effect of Initial Velocity Range increases quadratically with \\( v_0 \\) : [ R \\propto v_0^2 ] Effect of Gravitational Acceleration Range is inversely proportional to \\( g \\) : [ R \\propto \\frac{1}{g} ] 3. Practical Applications Real-world projectile motion often includes: Uneven terrain (non-zero launch and landing height) Air resistance (drag) Wind or spin (Magnus effect) To account for these, we would need to: Modify the equations to include drag force proportional to velocity. Adjust for initial and final height differences . Use numerical methods to solve non-linear equations. 4. Implementation (Python Simulation) Below is a Python script to visualize how the range varies with the angle of projection , for different initial velocities. ```python import numpy as np import matplotlib.pyplot as plt Constants g = 9.81 # gravitational acceleration (m/s^2) angles = np.linspace(0, 90, 100) # degrees radians = np.radians(angles) Initial velocities to compare initial_velocities = [10, 20, 30] plt.figure(figsize=(10, 6)) for v0 in initial_velocities: range_vals = (v0**2 * np.sin(2 * radians)) / g plt.plot(angles, range_vals, label=f'v\u2080 = {v0} m/s') plt.title(\"Range vs Angle of Projection\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid(True) plt.show() FINAL","title":"PROBLEM 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"PROBLEM 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"Projectile motion, while seemingly simple, offers a rich playground for exploring fundamental principles of physics. The basic idea is straightforward: analyze how the range of a projectile depends on its angle of projection . Yet, beneath this simplicity lies a complex and versatile framework. What makes this topic compelling is the number of free parameters involved\u2014such as initial velocity , gravitational acceleration , and launch height . These parameters allow for a diverse set of solutions that describe phenomena ranging from the arc of a soccer ball to the trajectory of a rocket.","title":"Motivation Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"We start with the fundamental equations of motion under constant acceleration due to gravity, assuming no air resistance.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Let: - \\( v_0 \\) : Initial velocity - \\( \\theta \\) : Angle of projection - \\( g \\) : Acceleration due to gravity (typically \\( 9.81 \\, \\text{m/s}^2 \\) ) - \\( R \\) : Horizontal range Decomposing the motion: Horizontal component: [ v_{x} = v_0 \\cos(\\theta) ] Vertical component: [ v_{y} = v_0 \\sin(\\theta) ] Time of flight \\( T \\) (for level ground): \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Range is then: \\[ R(\\theta) = v_{x} \\cdot T = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-angle-on-range","text":"The range is maximized when \\( \\sin(2\\theta) \\) is maximized. Max value of \\( \\sin(2\\theta) \\) is 1 when \\( 2\\theta = 90^\\circ \\) \u2192 \\( \\theta = 45^\\circ \\)","title":"Effect of Angle on Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-velocity","text":"Range increases quadratically with \\( v_0 \\) : [ R \\propto v_0^2 ]","title":"Effect of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-gravitational-acceleration","text":"Range is inversely proportional to \\( g \\) : [ R \\propto \\frac{1}{g} ]","title":"Effect of Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Real-world projectile motion often includes: Uneven terrain (non-zero launch and landing height) Air resistance (drag) Wind or spin (Magnus effect) To account for these, we would need to: Modify the equations to include drag force proportional to velocity. Adjust for initial and final height differences . Use numerical methods to solve non-linear equations.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation","text":"Below is a Python script to visualize how the range varies with the angle of projection , for different initial velocities. ```python import numpy as np import matplotlib.pyplot as plt","title":"4. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants","text":"g = 9.81 # gravitational acceleration (m/s^2) angles = np.linspace(0, 90, 100) # degrees radians = np.radians(angles)","title":"Constants"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#initial-velocities-to-compare","text":"initial_velocities = [10, 20, 30] plt.figure(figsize=(10, 6)) for v0 in initial_velocities: range_vals = (v0**2 * np.sin(2 * radians)) / g plt.plot(angles, range_vals, label=f'v\u2080 = {v0} m/s') plt.title(\"Range vs Angle of Projection\") plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.legend() plt.grid(True) plt.show() FINAL","title":"Initial velocities to compare"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a beautiful mess of physics \u2014 simple at first glance, but wildly complex when you start adding damping and driving forces. Instead of a clean swing back and forth, you get a whole zoo of behavior: resonance, chaos, and quasi-periodic motion. This system is a textbook example of how nonlinear dynamics emerge in real-world systems: from bridges vibrating in wind to circuits oscillating in sync with a signal. By tweaking a few knobs \u2014 like the damping factor, the amplitude of the driving force, or its frequency \u2014 the pendulum flips between elegant order and total chaos. 1. Theoretical Foundation Governing Equation The motion of a forced damped pendulum is described by the nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) : angular displacement \\( \\gamma \\) : damping coefficient \\( \\omega_0 \\) : natural frequency of the pendulum \\( (\\omega_0 = \\sqrt{\\frac{g}{L}}) \\) \\( A \\) : amplitude of the driving force \\( \\omega \\) : angular frequency of the driving force Small-Angle Approximation For \\( \\theta \\ll 1 \\) , we can approximate: \\[ \\sin(\\theta) \\approx \\theta \\] This linearizes the equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] Resonance Resonance occurs when the driving frequency \\( \\omega \\) approaches the natural frequency \\( \\omega_0 \\) . Under resonance, the amplitude of oscillation grows (limited only by damping). 2. Analysis of Dynamics The behavior of the pendulum drastically changes with variations in: Damping \\( \\gamma \\) : High damping smooths everything out; low damping allows buildup of energy. Driving Amplitude \\( A \\) : Stronger forcing leads to nonlinear and chaotic effects. Driving Frequency \\( \\omega \\) : Dictates whether the system hits resonance or not. Chaos & Quasiperiodicity When: - Damping is moderate - Forcing is strong - Frequency is near resonance ...the pendulum can enter chaotic regimes , where tiny differences in initial conditions lead to wildly different outcomes. 3. Practical Applications The forced damped pendulum isn\u2019t just a classroom toy. It pops up in: Energy harvesting (piezoelectric oscillators) Suspension bridges (wind-induced vibrations) AC circuits (driven RLC circuits) Biomechanics (human walking modeled as forced oscillations) 4. Implementation (Python Simulation) Basic Simulation of the Forced Damped Pendulum ```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Parameters gamma = 0.5 # Damping coefficient omega0 = 1.5 # Natural frequency A = 1.2 # Driving force amplitude omega_drive = 2/3 # Driving frequency t_max = 100 # Duration dt = 0.01 # Time step Differential equation def pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] Initial conditions y0 = [0.2, 0.0] # [theta, omega] t_eval = np.arange(0, t_max, dt) Solve sol = solve_ivp(pendulum, [0, t_max], y0, t_eval=t_eval, method='RK45') Plot angular displacement plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title(\"Forced Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.grid(True) plt.legend() plt.show() FINAL","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a beautiful mess of physics \u2014 simple at first glance, but wildly complex when you start adding damping and driving forces. Instead of a clean swing back and forth, you get a whole zoo of behavior: resonance, chaos, and quasi-periodic motion. This system is a textbook example of how nonlinear dynamics emerge in real-world systems: from bridges vibrating in wind to circuits oscillating in sync with a signal. By tweaking a few knobs \u2014 like the damping factor, the amplitude of the driving force, or its frequency \u2014 the pendulum flips between elegant order and total chaos.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion of a forced damped pendulum is described by the nonlinear second-order differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) : angular displacement \\( \\gamma \\) : damping coefficient \\( \\omega_0 \\) : natural frequency of the pendulum \\( (\\omega_0 = \\sqrt{\\frac{g}{L}}) \\) \\( A \\) : amplitude of the driving force \\( \\omega \\) : angular frequency of the driving force","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For \\( \\theta \\ll 1 \\) , we can approximate: \\[ \\sin(\\theta) \\approx \\theta \\] This linearizes the equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\]","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance","text":"Resonance occurs when the driving frequency \\( \\omega \\) approaches the natural frequency \\( \\omega_0 \\) . Under resonance, the amplitude of oscillation grows (limited only by damping).","title":"Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"The behavior of the pendulum drastically changes with variations in: Damping \\( \\gamma \\) : High damping smooths everything out; low damping allows buildup of energy. Driving Amplitude \\( A \\) : Stronger forcing leads to nonlinear and chaotic effects. Driving Frequency \\( \\omega \\) : Dictates whether the system hits resonance or not.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#chaos-quasiperiodicity","text":"When: - Damping is moderate - Forcing is strong - Frequency is near resonance ...the pendulum can enter chaotic regimes , where tiny differences in initial conditions lead to wildly different outcomes.","title":"Chaos &amp; Quasiperiodicity"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum isn\u2019t just a classroom toy. It pops up in: Energy harvesting (piezoelectric oscillators) Suspension bridges (wind-induced vibrations) AC circuits (driven RLC circuits) Biomechanics (human walking modeled as forced oscillations)","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"","title":"4. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#basic-simulation-of-the-forced-damped-pendulum","text":"```python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"Basic Simulation of the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"gamma = 0.5 # Damping coefficient omega0 = 1.5 # Natural frequency A = 1.2 # Driving force amplitude omega_drive = 2/3 # Driving frequency t_max = 100 # Duration dt = 0.01 # Time step","title":"Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation","text":"def pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt]","title":"Differential equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#initial-conditions","text":"y0 = [0.2, 0.0] # [theta, omega] t_eval = np.arange(0, t_max, dt)","title":"Initial conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solve","text":"sol = solve_ivp(pendulum, [0, t_max], y0, t_eval=t_eval, method='RK45')","title":"Solve"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#plot-angular-displacement","text":"plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title(\"Forced Damped Pendulum Motion\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angular Displacement (rad)\") plt.grid(True) plt.legend() plt.show() FINAL","title":"Plot angular displacement"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation Kepler's Third Law of planetary motion relates the square of the orbital period of a planet to the cube of its orbital radius . This fundamental law allows us to calculate planetary motions and offers insights into the gravitational interactions governing the motion of celestial bodies. By analyzing this relationship, we can explore various phenomena, from satellite orbits to the structure of entire planetary systems. 1. Theoretical Foundation Deriving Kepler\u2019s Third Law for Circular Orbits We begin with the gravitational force that provides the centripetal force required for circular motion. According to Newton\u2019s Law of Gravitation: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Where: - \\( G \\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ) - \\( M \\) is the mass of the central body (e.g., Sun, Earth) - \\( m \\) is the mass of the orbiting body (e.g., a planet, satellite) - \\( r \\) is the orbital radius (distance from the center of the central body) For circular motion, the centripetal force is given by: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Where: - \\( v \\) is the orbital velocity of the satellite or planet. Setting the gravitational force equal to the centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Solving for \\( v \\) , the orbital velocity: \\[ v = \\sqrt{\\frac{G M}{r}} \\] Now, the orbital period \\( T \\) is the time it takes for the planet or satellite to complete one revolution. The distance traveled in one orbit is the circumference of the circle \\( 2\\pi r \\) , so the period is: \\[ T = \\frac{\\text{circumference}}{\\text{velocity}} = \\frac{2\\pi r}{v} \\] Substituting \\( v \\) from earlier: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides gives us the relationship: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] This is Kepler\u2019s Third Law , which states that the square of the orbital period \\( T^2 \\) is proportional to the cube of the orbital radius \\( r^3 \\) . This law is essential for understanding the motion of planets, satellites, and other celestial objects. 2. Implications for Astronomy Calculating Planetary Masses and Distances Kepler's Third Law is incredibly useful for determining the mass of a central body (such as the Sun or Earth) when the orbital period and radius are known. For example, by observing the Moon\u2019s orbital period and radius, we can estimate the mass of the Earth. Similarly, by studying the orbits of distant exoplanets, astronomers can infer the mass of the stars they orbit. Example: The Moon\u2019s Orbit The Moon orbits Earth with an orbital radius of approximately \\( 3.84 \\times 10^8 \\) meters and an orbital period of about 27.3 days. Using Kepler\u2019s Third Law, we can estimate the mass of the Earth if the orbital data of the Moon is known. 3. Real-World Examples Planets in the Solar System In the Solar System, all planets follow an orbital path around the Sun. By using Kepler\u2019s Third Law, we can compare the orbital periods and radii of planets to calculate their relative distances from the Sun. For instance: - Earth has an orbital period of 365.25 days and an orbital radius of 1 AU (astronomical unit). - Jupiter, with a much longer orbital period of about 11.86 Earth years, orbits the Sun at a much greater distance, roughly 5.2 AU. Satellites and Artificial Orbits In modern times, satellites orbiting Earth also obey Kepler's Third Law. Understanding this law helps in the design of satellite orbits for communication, GPS systems, and space stations. 4. Implementation (Python Simulation) Below is a Python script that simulates a circular orbit and verifies Kepler\u2019s Third Law. The program calculates the orbital period based on different orbital radii for a given central mass (e.g., mass of Earth). ```python import numpy as np import matplotlib.pyplot as plt Constants G = 6.674 * 10 -11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972 * 10 24 # Mass of Earth (kg) Orbital radii (in meters) radii = np.linspace(1e7, 1e9, 100) Orbital period (T) based on Kepler's third law: T^2 = (4\u03c0^2 r^3) / (GM) periods = 2 * np.pi * np.sqrt(radii**3 / (G * M)) Plotting the relationship between T^2 and r^3 plt.figure(figsize=(8, 6)) plt.plot(radii 3, periods 2, label=\"T^2 vs r^3\") plt.xlabel(\"r^3 (m^3)\") plt.ylabel(\"T^2 (s^2)\") plt.title(\"Kepler's Third Law: T^2 vs r^3\") plt.grid(True) plt.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law of planetary motion relates the square of the orbital period of a planet to the cube of its orbital radius . This fundamental law allows us to calculate planetary motions and offers insights into the gravitational interactions governing the motion of celestial bodies. By analyzing this relationship, we can explore various phenomena, from satellite orbits to the structure of entire planetary systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deriving-keplers-third-law-for-circular-orbits","text":"We begin with the gravitational force that provides the centripetal force required for circular motion. According to Newton\u2019s Law of Gravitation: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] Where: - \\( G \\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ) - \\( M \\) is the mass of the central body (e.g., Sun, Earth) - \\( m \\) is the mass of the orbiting body (e.g., a planet, satellite) - \\( r \\) is the orbital radius (distance from the center of the central body) For circular motion, the centripetal force is given by: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Where: - \\( v \\) is the orbital velocity of the satellite or planet. Setting the gravitational force equal to the centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Solving for \\( v \\) , the orbital velocity: \\[ v = \\sqrt{\\frac{G M}{r}} \\] Now, the orbital period \\( T \\) is the time it takes for the planet or satellite to complete one revolution. The distance traveled in one orbit is the circumference of the circle \\( 2\\pi r \\) , so the period is: \\[ T = \\frac{\\text{circumference}}{\\text{velocity}} = \\frac{2\\pi r}{v} \\] Substituting \\( v \\) from earlier: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] Squaring both sides gives us the relationship: \\[ T^2 = \\frac{4\\pi^2 r^3}{G M} \\] This is Kepler\u2019s Third Law , which states that the square of the orbital period \\( T^2 \\) is proportional to the cube of the orbital radius \\( r^3 \\) . This law is essential for understanding the motion of planets, satellites, and other celestial objects.","title":"Deriving Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-planetary-masses-and-distances","text":"Kepler's Third Law is incredibly useful for determining the mass of a central body (such as the Sun or Earth) when the orbital period and radius are known. For example, by observing the Moon\u2019s orbital period and radius, we can estimate the mass of the Earth. Similarly, by studying the orbits of distant exoplanets, astronomers can infer the mass of the stars they orbit.","title":"Calculating Planetary Masses and Distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#example-the-moons-orbit","text":"The Moon orbits Earth with an orbital radius of approximately \\( 3.84 \\times 10^8 \\) meters and an orbital period of about 27.3 days. Using Kepler\u2019s Third Law, we can estimate the mass of the Earth if the orbital data of the Moon is known.","title":"Example: The Moon\u2019s Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-real-world-examples","text":"","title":"3. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#planets-in-the-solar-system","text":"In the Solar System, all planets follow an orbital path around the Sun. By using Kepler\u2019s Third Law, we can compare the orbital periods and radii of planets to calculate their relative distances from the Sun. For instance: - Earth has an orbital period of 365.25 days and an orbital radius of 1 AU (astronomical unit). - Jupiter, with a much longer orbital period of about 11.86 Earth years, orbits the Sun at a much greater distance, roughly 5.2 AU.","title":"Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#satellites-and-artificial-orbits","text":"In modern times, satellites orbiting Earth also obey Kepler's Third Law. Understanding this law helps in the design of satellite orbits for communication, GPS systems, and space stations.","title":"Satellites and Artificial Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-implementation-python-simulation","text":"Below is a Python script that simulates a circular orbit and verifies Kepler\u2019s Third Law. The program calculates the orbital period based on different orbital radii for a given central mass (e.g., mass of Earth). ```python import numpy as np import matplotlib.pyplot as plt","title":"4. Implementation (Python Simulation)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"G = 6.674 * 10 -11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972 * 10 24 # Mass of Earth (kg)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-radii-in-meters","text":"radii = np.linspace(1e7, 1e9, 100)","title":"Orbital radii (in meters)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-t-based-on-keplers-third-law-t2-42-r3-gm","text":"periods = 2 * np.pi * np.sqrt(radii**3 / (G * M))","title":"Orbital period (T) based on Kepler's third law: T^2 = (4\u03c0^2 r^3) / (GM)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plotting-the-relationship-between-t2-and-r3","text":"plt.figure(figsize=(8, 6)) plt.plot(radii 3, periods 2, label=\"T^2 vs r^3\") plt.xlabel(\"r^3 (m^3)\") plt.ylabel(\"T^2 (s^2)\") plt.title(\"Kepler's Third Law: T^2 vs r^3\") plt.grid(True) plt.legend() plt.show()","title":"Plotting the relationship between T^2 and r^3"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is fundamental in understanding the conditions required to escape a celestial body's gravitational pull. Extending this concept, the first, second, and third cosmic velocities define the velocities required for different types of space missions: - First cosmic velocity : The velocity needed to stay in orbit around a celestial body. - Second cosmic velocity : The velocity needed to escape the gravitational influence of a celestial body. - Third cosmic velocity : The velocity required to escape the gravitational influence of a star, enabling travel to another star system. These velocities are pivotal in space exploration, from launching satellites to planning interplanetary and interstellar missions. 1. Theoretical Foundation Escape Velocity The escape velocity is the minimum velocity an object must have to break free from the gravitational influence of a celestial body without further propulsion. The formula for escape velocity \\( v_e \\) is derived from the conservation of energy, considering both kinetic energy and gravitational potential energy: \\[ v_e = \\sqrt{\\frac{2 G M}{r}} \\] Where: - \\( G \\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ) - \\( M \\) is the mass of the celestial body (e.g., Earth, Mars, Jupiter) - \\( r \\) is the radius of the celestial body First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the velocity needed for a stable orbit around a celestial body. This is the velocity an object must have to stay in orbit without falling back to the surface. The formula for orbital velocity \\( v_1 \\) is: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] This velocity corresponds to the speed required to maintain a circular orbit at a specific radius. Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the velocity needed to completely escape a celestial body\u2019s gravitational pull. It is twice the value of the first cosmic velocity: \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\] This is the same as the formula for escape velocity , meaning it is the velocity required to leave the body\u2019s gravitational influence. Third Cosmic Velocity (Escape from a Star System) The third cosmic velocity is the velocity needed to escape the gravitational influence of the Sun (or any central star), which would enable an object to travel to another star system. This can be calculated as: \\[ v_3 = \\sqrt{\\frac{2 G M_{\\text{star}}}{r_{\\text{star}}} + \\frac{2 G M_{\\text{planet}}}{r_{\\text{planet}}}} \\] Where: - \\( M_{\\text{star}} \\) is the mass of the central star (e.g., the Sun) - \\( r_{\\text{star}} \\) is the distance from the star (in this case, the distance from the Sun to the planet, like Earth) - \\( M_{\\text{planet}} \\) and \\( r_{\\text{planet}} \\) are the mass and radius of the planet from which the object is escaping. 2. Practical Applications Escape Velocities and Space Exploration Launching Satellites : The first cosmic velocity is essential for launching satellites into orbit. For example, satellites orbiting Earth need to reach the first cosmic velocity to avoid falling back to Earth. Interplanetary Missions : The second cosmic velocity is required for missions that escape Earth's gravity, such as spacecraft heading to other planets or the Moon. Interstellar Travel : The third cosmic velocity is theoretical for interstellar travel, as it involves escaping the gravitational pull of the Sun to reach another star system. 3. Implementation (Python Simulation) Below is a Python script that calculates and visualizes the escape velocities and cosmic velocities for different celestial bodies, including Earth, Mars, and Jupiter. ```python import numpy as np import matplotlib.pyplot as plt Constants G = 6.674 * 10**-11 # Gravitational constant (m^3 kg^-1 s^-2) Celestial bodies: (Mass in kg, Radius in meters) bodies = { \"Earth\": {\"M\": 5.972 * 10 24, \"r\": 6.371 * 10 6}, \"Mars\": {\"M\": 0.64171 * 10 24, \"r\": 3.396 * 10 6}, \"Jupiter\": {\"M\": 1.898 * 10 27, \"r\": 6.991 * 10 7} } Function to calculate escape and cosmic velocities def escape_velocity(M, r): return np.sqrt(2 * G * M / r) def first_cosmic_velocity(M, r): return np.sqrt(G * M / r) def third_cosmic_velocity(M_star, r_star, M_planet, r_planet): return np.sqrt((2 * G * M_star / r_star) + (2 * G * M_planet / r_planet)) Calculate velocities velocities = {} for body, params in bodies.items(): M = params[\"M\"] r = params[\"r\"] v1 = first_cosmic_velocity(M, r) v2 = escape_velocity(M, r) # Using the Sun's mass and Earth's distance for third cosmic velocity calculation if body == \"Earth\": v3 = third_cosmic_velocity(1.989 * 10**30, 1.496 * 10**11, M, r) # Sun's mass and Earth's distance else: v3 = np.nan # Not calculating third cosmic velocity for Mars and Jupiter here velocities[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} Plotting the velocities fig, ax = plt.subplots(figsize=(10, 6)) bodies_names = list(bodies.keys()) v1_values = [velocities[body][\"v1\"] for body in bodies_names] v2_values = [velocities[body][\"v2\"] for body in bodies_names] v3_values = [velocities[body][\"v3\"] if not np.isnan(velocities[body][\"v3\"]) else np.nan for body in bodies_names] bar_width = 0.25 index = np.arange(len(bodies_names)) Plot bars for each velocity type ax.bar(index, v1_values, bar_width, label='First Cosmic Velocity (Orbital Velocity)') ax.bar(index + bar_width, v2_values, bar_width, label='Second Cosmic Velocity (Escape Velocity)') ax.bar(index + 2 * bar_width, v3_values, bar_width, label='Third Cosmic Velocity') Formatting the chart ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(index + bar_width) ax.set_xticklabels(bodies_names) ax.legend() plt.show() OKAY","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is fundamental in understanding the conditions required to escape a celestial body's gravitational pull. Extending this concept, the first, second, and third cosmic velocities define the velocities required for different types of space missions: - First cosmic velocity : The velocity needed to stay in orbit around a celestial body. - Second cosmic velocity : The velocity needed to escape the gravitational influence of a celestial body. - Third cosmic velocity : The velocity required to escape the gravitational influence of a star, enabling travel to another star system. These velocities are pivotal in space exploration, from launching satellites to planning interplanetary and interstellar missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocity","text":"The escape velocity is the minimum velocity an object must have to break free from the gravitational influence of a celestial body without further propulsion. The formula for escape velocity \\( v_e \\) is derived from the conservation of energy, considering both kinetic energy and gravitational potential energy: \\[ v_e = \\sqrt{\\frac{2 G M}{r}} \\] Where: - \\( G \\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ) - \\( M \\) is the mass of the celestial body (e.g., Earth, Mars, Jupiter) - \\( r \\) is the radius of the celestial body","title":"Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the velocity needed for a stable orbit around a celestial body. This is the velocity an object must have to stay in orbit without falling back to the surface. The formula for orbital velocity \\( v_1 \\) is: \\[ v_1 = \\sqrt{\\frac{G M}{r}} \\] This velocity corresponds to the speed required to maintain a circular orbit at a specific radius.","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the velocity needed to completely escape a celestial body\u2019s gravitational pull. It is twice the value of the first cosmic velocity: \\[ v_2 = \\sqrt{\\frac{2 G M}{r}} \\] This is the same as the formula for escape velocity , meaning it is the velocity required to leave the body\u2019s gravitational influence.","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-escape-from-a-star-system","text":"The third cosmic velocity is the velocity needed to escape the gravitational influence of the Sun (or any central star), which would enable an object to travel to another star system. This can be calculated as: \\[ v_3 = \\sqrt{\\frac{2 G M_{\\text{star}}}{r_{\\text{star}}} + \\frac{2 G M_{\\text{planet}}}{r_{\\text{planet}}}} \\] Where: - \\( M_{\\text{star}} \\) is the mass of the central star (e.g., the Sun) - \\( r_{\\text{star}} \\) is the distance from the star (in this case, the distance from the Sun to the planet, like Earth) - \\( M_{\\text{planet}} \\) and \\( r_{\\text{planet}} \\) are the mass and radius of the planet from which the object is escaping.","title":"Third Cosmic Velocity (Escape from a Star System)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-practical-applications","text":"","title":"2. Practical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-space-exploration","text":"Launching Satellites : The first cosmic velocity is essential for launching satellites into orbit. For example, satellites orbiting Earth need to reach the first cosmic velocity to avoid falling back to Earth. Interplanetary Missions : The second cosmic velocity is required for missions that escape Earth's gravity, such as spacecraft heading to other planets or the Moon. Interstellar Travel : The third cosmic velocity is theoretical for interstellar travel, as it involves escaping the gravitational pull of the Sun to reach another star system.","title":"Escape Velocities and Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-implementation-python-simulation","text":"Below is a Python script that calculates and visualizes the escape velocities and cosmic velocities for different celestial bodies, including Earth, Mars, and Jupiter. ```python import numpy as np import matplotlib.pyplot as plt","title":"3. Implementation (Python Simulation)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#constants","text":"G = 6.674 * 10**-11 # Gravitational constant (m^3 kg^-1 s^-2)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#celestial-bodies-mass-in-kg-radius-in-meters","text":"bodies = { \"Earth\": {\"M\": 5.972 * 10 24, \"r\": 6.371 * 10 6}, \"Mars\": {\"M\": 0.64171 * 10 24, \"r\": 3.396 * 10 6}, \"Jupiter\": {\"M\": 1.898 * 10 27, \"r\": 6.991 * 10 7} }","title":"Celestial bodies: (Mass in kg, Radius in meters)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#function-to-calculate-escape-and-cosmic-velocities","text":"def escape_velocity(M, r): return np.sqrt(2 * G * M / r) def first_cosmic_velocity(M, r): return np.sqrt(G * M / r) def third_cosmic_velocity(M_star, r_star, M_planet, r_planet): return np.sqrt((2 * G * M_star / r_star) + (2 * G * M_planet / r_planet))","title":"Function to calculate escape and cosmic velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#calculate-velocities","text":"velocities = {} for body, params in bodies.items(): M = params[\"M\"] r = params[\"r\"] v1 = first_cosmic_velocity(M, r) v2 = escape_velocity(M, r) # Using the Sun's mass and Earth's distance for third cosmic velocity calculation if body == \"Earth\": v3 = third_cosmic_velocity(1.989 * 10**30, 1.496 * 10**11, M, r) # Sun's mass and Earth's distance else: v3 = np.nan # Not calculating third cosmic velocity for Mars and Jupiter here velocities[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3}","title":"Calculate velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#plotting-the-velocities","text":"fig, ax = plt.subplots(figsize=(10, 6)) bodies_names = list(bodies.keys()) v1_values = [velocities[body][\"v1\"] for body in bodies_names] v2_values = [velocities[body][\"v2\"] for body in bodies_names] v3_values = [velocities[body][\"v3\"] if not np.isnan(velocities[body][\"v3\"]) else np.nan for body in bodies_names] bar_width = 0.25 index = np.arange(len(bodies_names))","title":"Plotting the velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#plot-bars-for-each-velocity-type","text":"ax.bar(index, v1_values, bar_width, label='First Cosmic Velocity (Orbital Velocity)') ax.bar(index + bar_width, v2_values, bar_width, label='Second Cosmic Velocity (Escape Velocity)') ax.bar(index + 2 * bar_width, v3_values, bar_width, label='Third Cosmic Velocity')","title":"Plot bars for each velocity type"},{"location":"1%20Physics/2%20Gravity/Problem_2/#formatting-the-chart","text":"ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(index + bar_width) ax.set_xticklabels(bodies_names) ax.legend() plt.show() OKAY","title":"Formatting the chart"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory is determined by initial conditions such as position, velocity, and altitude, along with gravitational forces. This problem blends principles of orbital mechanics and numerical methods. Understanding these trajectories is crucial for space missions, including payload deployment, orbital insertion, reentry, and escape scenarios. 1. Theoretical Foundation The trajectory of a payload released near Earth is influenced by Earth's gravitational pull, which follows Newton's Law of Gravitation . The law states that the gravitational force between two objects is proportional to their masses and inversely proportional to the square of the distance between their centers: \\[ F = \\frac{G M_1 M_2}{r^2} \\] Where: - \\( F \\) is the gravitational force - \\( G \\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ) - \\( M_1 \\) and \\( M_2 \\) are the masses of the two objects (in this case, Earth and the payload) - \\( r \\) is the distance between the centers of the two objects The gravitational acceleration \\( g \\) near Earth's surface is approximately \\(9.8 \\, \\text{m/s}^2\\) , but this changes with altitude. Types of Trajectories Parabolic Trajectory : If the velocity is less than the escape velocity but sufficient to overcome Earth's gravitational pull, the trajectory will be a parabola. Hyperbolic Trajectory : If the object is released with a velocity greater than the escape velocity, the trajectory will be hyperbolic, indicating that the object is escaping Earth's gravitational influence. Elliptical Trajectory : If the object's velocity is less than the escape velocity but greater than the orbital velocity, the trajectory will be elliptical, which is characteristic of orbital motion. Governing Equations For a two-body system, the trajectory of the payload is governed by the following equations derived from Newton's second law and the gravitational force: \\[ \\ddot{r} = -\\frac{GM}{r^2} \\] Where \\( \\ddot{r} \\) is the acceleration of the payload, \\( r \\) is the distance from the center of Earth, and \\( M \\) is the mass of Earth. In the absence of air resistance, the motion can be described in polar coordinates, where the position of the object is defined by radius \\( r \\) and angle \\( \\theta \\) . 2. Numerical Analysis We will use numerical methods to simulate the trajectory of the payload, considering different initial conditions (position, velocity, and altitude). Specifically, we will use Euler\u2019s method to solve the equations of motion iteratively. Initial Conditions Initial position \\( r_0 \\) : Distance from the center of the Earth (radius of Earth + altitude) Initial velocity \\( v_0 \\) : The speed of the payload at the moment of release Initial angle \\( \\theta_0 \\) : The direction of the velocity vector The direction of the velocity vector determines whether the trajectory is elliptical, parabolic, or hyperbolic. 3. Implementation (Python Simulation) Below is a Python script to simulate and visualize the trajectory of a freely released payload near Earth. This code solves the equations of motion using a simple numerical integration method (Euler\u2019s method) and plots the resulting trajectory. ```python import numpy as np import matplotlib.pyplot as plt Constants G = 6.674 * 10 -11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972 * 10 24 # Mass of Earth (kg) R_earth = 6.371 * 10**6 # Radius of Earth (m) Initial conditions r_0 = R_earth + 500000 # Initial position (500 km altitude) v_0 = 8000 # Initial velocity (m/s) - roughly 8 km/s theta_0 = 0 # Angle of velocity vector (0 for horizontal) Time parameters t_max = 10000 # Maximum time for the simulation (s) dt = 10 # Time step (s) Convert to polar coordinates r = r_0 # Distance from the center of Earth theta = theta_0 # Angle in the plane of motion v = v_0 # Velocity magnitude vx = v * np.cos(theta) # Velocity in x-direction vy = v * np.sin(theta) # Velocity in y-direction Arrays to store positions for plotting times = np.arange(0, t_max, dt) x_vals = [] y_vals = [] Euler's method for numerical integration for t in times: # Compute gravitational force F_gravity = G * M_earth / r**2 # Gravitational force (N) ax = -F_gravity * np.cos(theta) # Acceleration in x-direction ay = -F_gravity * np.sin(theta) # Acceleration in y-direction # Update velocity and position vx += ax * dt # Update velocity in x-direction vy += ay * dt # Update velocity in y-direction r = np.sqrt(x_vals[-1]**2 + y_vals[-1]**2) # Update radius x_vals.append(x_vals[-1] + vx * dt) # Update x position y_vals.append(y_vals[-1] + vy * dt) # Update y position Plot the trajectory plt.figure(figsize=(8, 6)) plt.plot(x_vals, y_vals, label='Payload Trajectory') plt.scatter(0, 0, color='r', label='Earth') # Earth's position plt.title('Trajectory of a Payload Released Near Earth') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid(True) plt.show() CMON","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory is determined by initial conditions such as position, velocity, and altitude, along with gravitational forces. This problem blends principles of orbital mechanics and numerical methods. Understanding these trajectories is crucial for space missions, including payload deployment, orbital insertion, reentry, and escape scenarios.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-foundation","text":"The trajectory of a payload released near Earth is influenced by Earth's gravitational pull, which follows Newton's Law of Gravitation . The law states that the gravitational force between two objects is proportional to their masses and inversely proportional to the square of the distance between their centers: \\[ F = \\frac{G M_1 M_2}{r^2} \\] Where: - \\( F \\) is the gravitational force - \\( G \\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ) - \\( M_1 \\) and \\( M_2 \\) are the masses of the two objects (in this case, Earth and the payload) - \\( r \\) is the distance between the centers of the two objects The gravitational acceleration \\( g \\) near Earth's surface is approximately \\(9.8 \\, \\text{m/s}^2\\) , but this changes with altitude.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"Parabolic Trajectory : If the velocity is less than the escape velocity but sufficient to overcome Earth's gravitational pull, the trajectory will be a parabola. Hyperbolic Trajectory : If the object is released with a velocity greater than the escape velocity, the trajectory will be hyperbolic, indicating that the object is escaping Earth's gravitational influence. Elliptical Trajectory : If the object's velocity is less than the escape velocity but greater than the orbital velocity, the trajectory will be elliptical, which is characteristic of orbital motion.","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations","text":"For a two-body system, the trajectory of the payload is governed by the following equations derived from Newton's second law and the gravitational force: \\[ \\ddot{r} = -\\frac{GM}{r^2} \\] Where \\( \\ddot{r} \\) is the acceleration of the payload, \\( r \\) is the distance from the center of Earth, and \\( M \\) is the mass of Earth. In the absence of air resistance, the motion can be described in polar coordinates, where the position of the object is defined by radius \\( r \\) and angle \\( \\theta \\) .","title":"Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-numerical-analysis","text":"We will use numerical methods to simulate the trajectory of the payload, considering different initial conditions (position, velocity, and altitude). Specifically, we will use Euler\u2019s method to solve the equations of motion iteratively.","title":"2. Numerical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"Initial position \\( r_0 \\) : Distance from the center of the Earth (radius of Earth + altitude) Initial velocity \\( v_0 \\) : The speed of the payload at the moment of release Initial angle \\( \\theta_0 \\) : The direction of the velocity vector The direction of the velocity vector determines whether the trajectory is elliptical, parabolic, or hyperbolic.","title":"Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-implementation-python-simulation","text":"Below is a Python script to simulate and visualize the trajectory of a freely released payload near Earth. This code solves the equations of motion using a simple numerical integration method (Euler\u2019s method) and plots the resulting trajectory. ```python import numpy as np import matplotlib.pyplot as plt","title":"3. Implementation (Python Simulation)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.674 * 10 -11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972 * 10 24 # Mass of Earth (kg) R_earth = 6.371 * 10**6 # Radius of Earth (m)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions_1","text":"r_0 = R_earth + 500000 # Initial position (500 km altitude) v_0 = 8000 # Initial velocity (m/s) - roughly 8 km/s theta_0 = 0 # Angle of velocity vector (0 for horizontal)","title":"Initial conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#time-parameters","text":"t_max = 10000 # Maximum time for the simulation (s) dt = 10 # Time step (s)","title":"Time parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#convert-to-polar-coordinates","text":"r = r_0 # Distance from the center of Earth theta = theta_0 # Angle in the plane of motion v = v_0 # Velocity magnitude vx = v * np.cos(theta) # Velocity in x-direction vy = v * np.sin(theta) # Velocity in y-direction","title":"Convert to polar coordinates"},{"location":"1%20Physics/2%20Gravity/Problem_3/#arrays-to-store-positions-for-plotting","text":"times = np.arange(0, t_max, dt) x_vals = [] y_vals = []","title":"Arrays to store positions for plotting"},{"location":"1%20Physics/2%20Gravity/Problem_3/#eulers-method-for-numerical-integration","text":"for t in times: # Compute gravitational force F_gravity = G * M_earth / r**2 # Gravitational force (N) ax = -F_gravity * np.cos(theta) # Acceleration in x-direction ay = -F_gravity * np.sin(theta) # Acceleration in y-direction # Update velocity and position vx += ax * dt # Update velocity in x-direction vy += ay * dt # Update velocity in y-direction r = np.sqrt(x_vals[-1]**2 + y_vals[-1]**2) # Update radius x_vals.append(x_vals[-1] + vx * dt) # Update x position y_vals.append(y_vals[-1] + vy * dt) # Update y position","title":"Euler's method for numerical integration"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plot-the-trajectory","text":"plt.figure(figsize=(8, 6)) plt.plot(x_vals, y_vals, label='Payload Trajectory') plt.scatter(0, 0, color='r', label='Earth') # Earth's position plt.title('Trajectory of a Payload Released Near Earth') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.legend() plt.grid(True) plt.show() CMON","title":"Plot the trajectory"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, forming new patterns on the surface of a medium, such as water. These patterns can illustrate how waves combine in various ways: constructive interference (wave reinforcement) or destructive interference (wave cancellation). Studying these patterns helps us understand fundamental wave behaviors, such as the relationship between wave phase and the effect of multiple sources. This problem involves analyzing the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a regular polygon. By exploring this phenomenon, we gain insight into wave interactions and their real-world applications. 1. Theoretical Foundation Wave Equation A circular wave on a water surface, originating from a point source, is described by the following equation: \\[ \\psi(\\mathbf{r}, t) = A \\cdot \\cos(k r - \\omega t + \\phi) \\] Where: - \\( \\psi(\\mathbf{r}, t) \\) is the displacement of the water surface at point \\( \\mathbf{r} \\) and time \\( t \\) - \\( A \\) is the amplitude of the wave - \\( k \\) is the wave number, related to the wavelength \\( \\lambda \\) , where \\( k = \\frac{2\\pi}{\\lambda} \\) - \\( \\omega \\) is the angular frequency, related to the frequency \\( f \\) , where \\( \\omega = 2\\pi f \\) - \\( r \\) is the distance from the source to the observation point - \\( \\phi \\) is the initial phase of the wave Superposition Principle The principle of superposition states that when multiple waves overlap, the resulting displacement is the sum of the displacements from all individual waves. Thus, for \\( N \\) sources located at the vertices of a regular polygon, the total displacement at a point on the surface is: \\[ \\Psi(\\mathbf{r}, t) = \\sum_{i=1}^{N} A_i \\cdot \\cos(k r_i - \\omega t + \\phi_i) \\] Where: - \\( N \\) is the number of sources (vertices of the polygon) - \\( A_i \\) , \\( r_i \\) , and \\( \\phi_i \\) are the amplitude, distance, and initial phase of the wave from the \\( i^{th} \\) source, respectively. Interference Patterns Constructive Interference : Occurs when the waves from different sources are in phase, leading to wave reinforcement and higher displacement. Destructive Interference : Occurs when the waves are out of phase, leading to wave cancellation and lower displacement. The interference pattern depends on the relative phase and position of the sources and the observation point. 2. Simulation and Visualization Steps to Implement: Choose a Regular Polygon : For simplicity, we will use a square (4 vertices). Position the Sources : The point sources are placed at the vertices of the square. Write the Wave Equations : For each source, the wave will follow the equation described above. Apply Superposition : Sum the contributions from all sources at each point on the water surface. Analyze the Resulting Pattern : Observe regions of constructive and destructive interference. 3. Python Implementation Below is a Python script that simulates the interference pattern of waves emitted from the vertices of a square (or any regular polygon). It uses the matplotlib library for visualization and numpy for numerical calculations. ```python import numpy as np import matplotlib.pyplot as plt Constants A = 1 # Amplitude of the waves k = 2 * np.pi / 1.0 # Wave number (assuming wavelength = 1 meter) omega = 2 * np.pi # Angular frequency (assuming frequency = 1 Hz) phi = 0 # Initial phase of the waves Set up the grid for the water surface x_max, y_max = 10, 10 # Size of the water surface grid (10m x 10m) x = np.linspace(-x_max, x_max, 500) y = np.linspace(-y_max, y_max, 500) X, Y = np.meshgrid(x, y) Define the number of sources and their positions for a square N_sources = 4 # Number of sources (vertices of a square) radius = 5 # Distance from the center to the sources Positions of the sources (vertices of a square) angles = np.linspace(0, 2 * np.pi, N_sources, endpoint=False) source_positions = np.array([radius * np.cos(angles), radius * np.sin(angles)]) Superposition of waves from all sources def wave_sum(X, Y, source_positions, A, k, omega, phi): total_displacement = np.zeros(X.shape) for i in range(N_sources): # Calculate distance from each source to each point on the grid r = np.sqrt((X - source_positions[0, i])**2 + (Y - source_positions[1, i])**2) # Calculate the wave displacement for this source displacement = A * np.cos(k * r - omega * 0 + phi) # Assuming t = 0 for simplicity total_displacement += displacement # Sum the displacements return total_displacement Calculate the wave displacement on the water surface Z = wave_sum(X, Y, source_positions, A, k, omega, phi) Plotting the interference pattern plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, cmap='seismic', levels=np.linspace(-4, 4, 50)) plt.colorbar(label='Displacement') plt.title('Interference Pattern of Waves from Square Sources') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.show() YEPP","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, forming new patterns on the surface of a medium, such as water. These patterns can illustrate how waves combine in various ways: constructive interference (wave reinforcement) or destructive interference (wave cancellation). Studying these patterns helps us understand fundamental wave behaviors, such as the relationship between wave phase and the effect of multiple sources. This problem involves analyzing the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a regular polygon. By exploring this phenomenon, we gain insight into wave interactions and their real-world applications.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation","text":"A circular wave on a water surface, originating from a point source, is described by the following equation: \\[ \\psi(\\mathbf{r}, t) = A \\cdot \\cos(k r - \\omega t + \\phi) \\] Where: - \\( \\psi(\\mathbf{r}, t) \\) is the displacement of the water surface at point \\( \\mathbf{r} \\) and time \\( t \\) - \\( A \\) is the amplitude of the wave - \\( k \\) is the wave number, related to the wavelength \\( \\lambda \\) , where \\( k = \\frac{2\\pi}{\\lambda} \\) - \\( \\omega \\) is the angular frequency, related to the frequency \\( f \\) , where \\( \\omega = 2\\pi f \\) - \\( r \\) is the distance from the source to the observation point - \\( \\phi \\) is the initial phase of the wave","title":"Wave Equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-principle","text":"The principle of superposition states that when multiple waves overlap, the resulting displacement is the sum of the displacements from all individual waves. Thus, for \\( N \\) sources located at the vertices of a regular polygon, the total displacement at a point on the surface is: \\[ \\Psi(\\mathbf{r}, t) = \\sum_{i=1}^{N} A_i \\cdot \\cos(k r_i - \\omega t + \\phi_i) \\] Where: - \\( N \\) is the number of sources (vertices of the polygon) - \\( A_i \\) , \\( r_i \\) , and \\( \\phi_i \\) are the amplitude, distance, and initial phase of the wave from the \\( i^{th} \\) source, respectively.","title":"Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns","text":"Constructive Interference : Occurs when the waves from different sources are in phase, leading to wave reinforcement and higher displacement. Destructive Interference : Occurs when the waves are out of phase, leading to wave cancellation and lower displacement. The interference pattern depends on the relative phase and position of the sources and the observation point.","title":"Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-simulation-and-visualization","text":"","title":"2. Simulation and Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-implement","text":"Choose a Regular Polygon : For simplicity, we will use a square (4 vertices). Position the Sources : The point sources are placed at the vertices of the square. Write the Wave Equations : For each source, the wave will follow the equation described above. Apply Superposition : Sum the contributions from all sources at each point on the water surface. Analyze the Resulting Pattern : Observe regions of constructive and destructive interference.","title":"Steps to Implement:"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-python-implementation","text":"Below is a Python script that simulates the interference pattern of waves emitted from the vertices of a square (or any regular polygon). It uses the matplotlib library for visualization and numpy for numerical calculations. ```python import numpy as np import matplotlib.pyplot as plt","title":"3. Python Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#constants","text":"A = 1 # Amplitude of the waves k = 2 * np.pi / 1.0 # Wave number (assuming wavelength = 1 meter) omega = 2 * np.pi # Angular frequency (assuming frequency = 1 Hz) phi = 0 # Initial phase of the waves","title":"Constants"},{"location":"1%20Physics/3%20Waves/Problem_1/#set-up-the-grid-for-the-water-surface","text":"x_max, y_max = 10, 10 # Size of the water surface grid (10m x 10m) x = np.linspace(-x_max, x_max, 500) y = np.linspace(-y_max, y_max, 500) X, Y = np.meshgrid(x, y)","title":"Set up the grid for the water surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#define-the-number-of-sources-and-their-positions-for-a-square","text":"N_sources = 4 # Number of sources (vertices of a square) radius = 5 # Distance from the center to the sources","title":"Define the number of sources and their positions for a square"},{"location":"1%20Physics/3%20Waves/Problem_1/#positions-of-the-sources-vertices-of-a-square","text":"angles = np.linspace(0, 2 * np.pi, N_sources, endpoint=False) source_positions = np.array([radius * np.cos(angles), radius * np.sin(angles)])","title":"Positions of the sources (vertices of a square)"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves-from-all-sources","text":"def wave_sum(X, Y, source_positions, A, k, omega, phi): total_displacement = np.zeros(X.shape) for i in range(N_sources): # Calculate distance from each source to each point on the grid r = np.sqrt((X - source_positions[0, i])**2 + (Y - source_positions[1, i])**2) # Calculate the wave displacement for this source displacement = A * np.cos(k * r - omega * 0 + phi) # Assuming t = 0 for simplicity total_displacement += displacement # Sum the displacements return total_displacement","title":"Superposition of waves from all sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#calculate-the-wave-displacement-on-the-water-surface","text":"Z = wave_sum(X, Y, source_positions, A, k, omega, phi)","title":"Calculate the wave displacement on the water surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#plotting-the-interference-pattern","text":"plt.figure(figsize=(8, 6)) plt.contourf(X, Y, Z, cmap='seismic', levels=np.linspace(-4, 4, 50)) plt.colorbar(label='Displacement') plt.title('Interference Pattern of Waves from Square Sources') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.show() YEPP","title":"Plotting the interference pattern"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force is the force experienced by a charged particle moving in an electric and magnetic field. The force is given by: \\[ \\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Where: - \\( \\mathbf{F} \\) is the Lorentz force, - \\( q \\) is the charge of the particle, - \\( \\mathbf{E} \\) is the electric field, - \\( \\mathbf{v} \\) is the velocity of the particle, - \\( \\mathbf{B} \\) is the magnetic field. This force governs the motion of charged particles in fields and plays a key role in many physical systems, including particle accelerators, mass spectrometers, and plasma confinement devices. Simulations of the Lorentz force help visualize and explore the complex trajectories that arise due to these fields. 1. Exploration of Applications Key Systems Where Lorentz Force Plays a Role: Particle Accelerators : The Lorentz force is used to accelerate charged particles in cyclotrons and synchrotrons, where electric and magnetic fields are used to steer and accelerate particles to high velocities. Mass Spectrometers : In mass spectrometers, charged particles are deflected by magnetic fields, allowing for the determination of their mass-to-charge ratio. Plasma Confinement : Magnetic fields are used to confine hot plasma in fusion reactors (e.g., Tokamaks), where the motion of charged particles is controlled by Lorentz forces. Relevance of Electric and Magnetic Fields: Electric Fields ( \\( \\mathbf{E} \\) ) : Accelerate or decelerate charged particles along the direction of the field. Magnetic Fields ( \\( \\mathbf{B} \\) ) : Deflect charged particles, causing them to follow curved paths, depending on their velocity and charge. 2. Simulating Particle Motion We will simulate the motion of a charged particle under the influence of different electric and magnetic field configurations. The basic equation of motion is: \\[ m \\frac{d\\mathbf{v}}{dt} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Where: - \\( m \\) is the mass of the particle, - \\( \\mathbf{v} \\) is the velocity of the particle, - \\( \\mathbf{E} \\) and \\( \\mathbf{B} \\) are the electric and magnetic fields. Steps to Implement: Uniform Magnetic Field : Simulate the motion of a charged particle in a uniform magnetic field, which results in circular motion. Combined Electric and Magnetic Fields : Simulate the motion in both electric and magnetic fields, leading to helical trajectories. Crossed Electric and Magnetic Fields : Simulate the motion of the particle in crossed fields (electric and magnetic fields perpendicular to each other), resulting in drift motion. Parameter Exploration : Vary the particle\u2019s charge, mass, velocity, and field strengths to observe their influence on the trajectory. 3. Python Implementation Below is a Python script to simulate the motion of a charged particle under various field configurations using the Lorentz force. We will use the Runge-Kutta method to solve the equations of motion numerically. ```python import numpy as np import matplotlib.pyplot as plt Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) B = np.array([0, 0, 1]) # Magnetic field (T) along the z-axis E = np.array([0, 0, 0]) # Electric field (V/m), assuming no electric field for simplicity Initial conditions v0 = np.array([1e6, 0, 0]) # Initial velocity (m/s) r0 = np.array([0, 0, 0]) # Initial position (m) t_max = 10e-6 # Maximum time (s) dt = 1e-9 # Time step (s) Lorentz force calculation def lorentz_force(v, r, q, m, E, B): # v: velocity, r: position, q: charge, m: mass, E: electric field, B: magnetic field return (q / m) * (E + np.cross(v, B)) Runge-Kutta method for numerical integration def runge_kutta(v, r, q, m, E, B, dt): k1v = lorentz_force(v, r, q, m, E, B) k1r = v k2v = lorentz_force(v + 0.5 * k1v * dt, r + 0.5 * k1r * dt, q, m, E, B) k2r = v + 0.5 * k1v * dt k3v = lorentz_force(v + 0.5 * k2v * dt, r + 0.5 * k2r * dt, q, m, E, B) k3r = v + 0.5 * k2v * dt k4v = lorentz_force(v + k3v * dt, r + k3r * dt, q, m, E, B) k4r = v + k3v * dt # Update velocity and position v_new = v + (k1v + 2*k2v + 2*k3v + k4v) * dt / 6 r_new = r + (k1r + 2*k2r + 2*k3r + k4r) * dt / 6 return v_new, r_new Simulate the motion t = np.arange(0, t_max, dt) r = np.zeros((len(t), 3)) # Position array v = np.zeros((len(t), 3)) # Velocity array r[0] = r0 v[0] = v0 Integration loop for i in range(1, len(t)): v[i], r[i] = runge_kutta(v[i-1], r[i-1], q, m, E, B, dt) Plot the trajectory fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2]) ax.set_title(\"Trajectory of the Charged Particle\") ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') plt.show()","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force is the force experienced by a charged particle moving in an electric and magnetic field. The force is given by: \\[ \\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Where: - \\( \\mathbf{F} \\) is the Lorentz force, - \\( q \\) is the charge of the particle, - \\( \\mathbf{E} \\) is the electric field, - \\( \\mathbf{v} \\) is the velocity of the particle, - \\( \\mathbf{B} \\) is the magnetic field. This force governs the motion of charged particles in fields and plays a key role in many physical systems, including particle accelerators, mass spectrometers, and plasma confinement devices. Simulations of the Lorentz force help visualize and explore the complex trajectories that arise due to these fields.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-systems-where-lorentz-force-plays-a-role","text":"Particle Accelerators : The Lorentz force is used to accelerate charged particles in cyclotrons and synchrotrons, where electric and magnetic fields are used to steer and accelerate particles to high velocities. Mass Spectrometers : In mass spectrometers, charged particles are deflected by magnetic fields, allowing for the determination of their mass-to-charge ratio. Plasma Confinement : Magnetic fields are used to confine hot plasma in fusion reactors (e.g., Tokamaks), where the motion of charged particles is controlled by Lorentz forces.","title":"Key Systems Where Lorentz Force Plays a Role:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#relevance-of-electric-and-magnetic-fields","text":"Electric Fields ( \\( \\mathbf{E} \\) ) : Accelerate or decelerate charged particles along the direction of the field. Magnetic Fields ( \\( \\mathbf{B} \\) ) : Deflect charged particles, causing them to follow curved paths, depending on their velocity and charge.","title":"Relevance of Electric and Magnetic Fields:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"We will simulate the motion of a charged particle under the influence of different electric and magnetic field configurations. The basic equation of motion is: \\[ m \\frac{d\\mathbf{v}}{dt} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Where: - \\( m \\) is the mass of the particle, - \\( \\mathbf{v} \\) is the velocity of the particle, - \\( \\mathbf{E} \\) and \\( \\mathbf{B} \\) are the electric and magnetic fields.","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#steps-to-implement","text":"Uniform Magnetic Field : Simulate the motion of a charged particle in a uniform magnetic field, which results in circular motion. Combined Electric and Magnetic Fields : Simulate the motion in both electric and magnetic fields, leading to helical trajectories. Crossed Electric and Magnetic Fields : Simulate the motion of the particle in crossed fields (electric and magnetic fields perpendicular to each other), resulting in drift motion. Parameter Exploration : Vary the particle\u2019s charge, mass, velocity, and field strengths to observe their influence on the trajectory.","title":"Steps to Implement:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-python-implementation","text":"Below is a Python script to simulate the motion of a charged particle under various field configurations using the Lorentz force. We will use the Runge-Kutta method to solve the equations of motion numerically. ```python import numpy as np import matplotlib.pyplot as plt","title":"3. Python Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#constants","text":"q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) B = np.array([0, 0, 1]) # Magnetic field (T) along the z-axis E = np.array([0, 0, 0]) # Electric field (V/m), assuming no electric field for simplicity","title":"Constants"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#initial-conditions","text":"v0 = np.array([1e6, 0, 0]) # Initial velocity (m/s) r0 = np.array([0, 0, 0]) # Initial position (m) t_max = 10e-6 # Maximum time (s) dt = 1e-9 # Time step (s)","title":"Initial conditions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-calculation","text":"def lorentz_force(v, r, q, m, E, B): # v: velocity, r: position, q: charge, m: mass, E: electric field, B: magnetic field return (q / m) * (E + np.cross(v, B))","title":"Lorentz force calculation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#runge-kutta-method-for-numerical-integration","text":"def runge_kutta(v, r, q, m, E, B, dt): k1v = lorentz_force(v, r, q, m, E, B) k1r = v k2v = lorentz_force(v + 0.5 * k1v * dt, r + 0.5 * k1r * dt, q, m, E, B) k2r = v + 0.5 * k1v * dt k3v = lorentz_force(v + 0.5 * k2v * dt, r + 0.5 * k2r * dt, q, m, E, B) k3r = v + 0.5 * k2v * dt k4v = lorentz_force(v + k3v * dt, r + k3r * dt, q, m, E, B) k4r = v + k3v * dt # Update velocity and position v_new = v + (k1v + 2*k2v + 2*k3v + k4v) * dt / 6 r_new = r + (k1r + 2*k2r + 2*k3r + k4r) * dt / 6 return v_new, r_new","title":"Runge-Kutta method for numerical integration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulate-the-motion","text":"t = np.arange(0, t_max, dt) r = np.zeros((len(t), 3)) # Position array v = np.zeros((len(t), 3)) # Velocity array r[0] = r0 v[0] = v0","title":"Simulate the motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#integration-loop","text":"for i in range(1, len(t)): v[i], r[i] = runge_kutta(v[i-1], r[i-1], q, m, E, B, dt)","title":"Integration loop"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plot-the-trajectory","text":"fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:, 0], r[:, 1], r[:, 2]) ax.set_title(\"Trajectory of the Charged Particle\") ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') plt.show()","title":"Plot the trajectory"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"import networkx as nx from collections import defaultdict class CircuitAnalyzer: def init (self): self.graph = nx.Graph() def add_resistor(self, node1, node2, resistance): \"\"\"Add a resistor between two nodes with given resistance\"\"\" self.graph.add_edge(node1, node2, resistance=resistance) def calculate_equivalent_resistance(self, start_node, end_node): \"\"\" Calculate equivalent resistance between two nodes using series-parallel reduction Returns the equivalent resistance or None if nodes are disconnected \"\"\" working_graph = self.graph.copy() while True: # Check if we've simplified to a single resistor if working_graph.number_of_edges() == 1: if start_node in working_graph and end_node in working_graph: return working_graph.edges[start_node, end_node]['resistance'] else: return None # Nodes are disconnected # Try series reduction first reduced = self._reduce_series(working_graph, start_node, end_node) if reduced: working_graph = reduced continue # Then try parallel reduction reduced = self._reduce_parallel(working_graph) if reduced: working_graph = reduced continue # If no more reductions possible but still multiple edges if working_graph.number_of_edges() > 1: print(\"Warning: Circuit contains non-series-parallel components\") return None break # Final check for direct connection if working_graph.has_edge(start_node, end_node): return working_graph.edges[start_node, end_node]['resistance'] return None def _reduce_series(self, graph, start_node, end_node): \"\"\" Reduce series resistors in the graph Returns a new simplified graph or None if no series reductions found \"\"\" # Find nodes with degree 2 (excluding start and end nodes) series_nodes = [ node for node in graph.nodes() if (node != start_node and node != end_node and graph.degree(node) == 2) ] if not series_nodes: return None # Create a copy to modify new_graph = graph.copy() for node in series_nodes: # Get the two neighbors neighbors = list(new_graph.neighbors(node)) if len(neighbors) != 2: continue a, b = neighbors # Calculate combined resistance r1 = new_graph.edges[node, a]['resistance'] r2 = new_graph.edges[node, b]['resistance'] total = r1 + r2 # Remove the series node and add new resistor new_graph.remove_node(node) new_graph.add_edge(a, b, resistance=total) # Only reduce one series at a time to avoid complications return new_graph return None def _reduce_parallel(self, graph): \"\"\" Reduce parallel resistors in the graph Returns a new simplified graph or None if no parallel reductions found \"\"\" # Find all pairs with multiple edges parallel_edges = defaultdict(list) for u, v in graph.edges(): if u > v: # To avoid duplicate (u,v) and (v,u) u, v = v, u parallel_edges[(u, v)].append((u, v)) # Find pairs with multiple edges between them parallel_pairs = [pair for pair, edges in parallel_edges.items() if len(edges) > 1] if not parallel_pairs: return None # Create a copy to modify new_graph = graph.copy() for u, v in parallel_pairs[:1]: # Only process one pair at a time # Get all resistances between u and v resistances = [] for edge in graph.edges(u, data=True): if edge[1] == v: resistances.append(edge[2]['resistance']) # Calculate equivalent parallel resistance if len(resistances) > 1: inv_total = sum(1/r for r in resistances) if inv_total == 0: equivalent = 0 # Short circuit case else: equivalent = 1 / inv_total # Remove all parallel edges and add one equivalent new_graph.remove_edges_from(list(graph.edges(u, v))) new_graph.add_edge(u, v, resistance=equivalent) return new_graph return None def test_circuits(): \"\"\"Test the implementation with example circuits\"\"\" print(\"Testing equivalent resistance calculator...\\n\") # Example 1: Simple series circuit print(\"Example 1: Simple series circuit (R1 + R2)\") analyzer = CircuitAnalyzer() analyzer.add_resistor('A', 'B', 10) # R1 = 10\u03a9 analyzer.add_resistor('B', 'C', 20) # R2 = 20\u03a9 equivalent = analyzer.calculate_equivalent_resistance('A', 'C') print(f\"Equivalent resistance between A and C: {equivalent} \u03a9 (Expected: 30 \u03a9)\\n\") # Example 2: Simple parallel circuit print(\"Example 2: Simple parallel circuit (R1 || R2)\") analyzer = CircuitAnalyzer() analyzer.add_resistor('A', 'B', 10) # R1 = 10\u03a9 analyzer.add_resistor('A', 'B', 20) # R2 = 20\u03a9 equivalent = analyzer.calculate_equivalent_resistance('A', 'B') print(f\"Equivalent resistance between A and B: {equivalent:.2f} \u03a9 (Expected: 6.67 \u03a9)\\n\") # Example 3: Nested series-parallel circuit print(\"Example 3: Nested series-parallel circuit\") analyzer = CircuitAnalyzer() analyzer.add_resistor('A', 'B', 10) # R1 = 10\u03a9 analyzer.add_resistor('B', 'C', 20) # R2 = 20\u03a9 analyzer.add_resistor('B', 'C', 30) # R3 = 30\u03a9 (parallel with R2) analyzer.add_resistor('C', 'D', 40) # R4 = 40\u03a9 equivalent = analyzer.calculate_equivalent_resistance('A', 'D') print(f\"Equivalent resistance between A and D: {equivalent:.2f} \u03a9 (Expected: 62.00 \u03a9)\\n\") if name == \" main \": test_circuits()","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 import numpy as np import matplotlib.pyplot as plt import seaborn as sns Function to generate and visualize sampling distributions def central_limit_theorem(population_size=10000, sample_sizes=[5, 10, 30, 50], num_samples=1000): # 1. Generate large datasets from different distributions uniform_population = np.random.uniform(0, 1, population_size) exponential_population = np.random.exponential(1, population_size) binomial_population = np.random.binomial(10, 0.5, population_size) # 2. Function to take random samples and calculate the sample means def sample_means(population, sample_size, num_samples): means = [] for _ in range(num_samples): sample = np.random.choice(population, size=sample_size, replace=False) means.append(np.mean(sample)) return means # 3. Create plots for each distribution and sample size fig, axes = plt.subplots(3, len(sample_sizes), figsize=(15, 12)) for i, sample_size in enumerate(sample_sizes): # Uniform distribution sampling uniform_means = sample_means(uniform_population, sample_size, num_samples) sns.histplot(uniform_means, bins=30, kde=True, ax=axes[0, i]) axes[0, i].set_title(f'Uniform Distribution - Sample Size {sample_size}') # Exponential distribution sampling exponential_means = sample_means(exponential_population, sample_size, num_samples) sns.histplot(exponential_means, bins=30, kde=True, ax=axes[1, i]) axes[1, i].set_title(f'Exponential Distribution - Sample Size {sample_size}') # Binomial distribution sampling binomial_means = sample_means(binomial_population, sample_size, num_samples) sns.histplot(binomial_means, bins=30, kde=True, ax=axes[2, i]) axes[2, i].set_title(f'Binomial Distribution - Sample Size {sample_size}') plt.tight_layout() plt.show() Run the simulation central_limit_theorem()","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#function-to-generate-and-visualize-sampling-distributions","text":"def central_limit_theorem(population_size=10000, sample_sizes=[5, 10, 30, 50], num_samples=1000): # 1. Generate large datasets from different distributions uniform_population = np.random.uniform(0, 1, population_size) exponential_population = np.random.exponential(1, population_size) binomial_population = np.random.binomial(10, 0.5, population_size) # 2. Function to take random samples and calculate the sample means def sample_means(population, sample_size, num_samples): means = [] for _ in range(num_samples): sample = np.random.choice(population, size=sample_size, replace=False) means.append(np.mean(sample)) return means # 3. Create plots for each distribution and sample size fig, axes = plt.subplots(3, len(sample_sizes), figsize=(15, 12)) for i, sample_size in enumerate(sample_sizes): # Uniform distribution sampling uniform_means = sample_means(uniform_population, sample_size, num_samples) sns.histplot(uniform_means, bins=30, kde=True, ax=axes[0, i]) axes[0, i].set_title(f'Uniform Distribution - Sample Size {sample_size}') # Exponential distribution sampling exponential_means = sample_means(exponential_population, sample_size, num_samples) sns.histplot(exponential_means, bins=30, kde=True, ax=axes[1, i]) axes[1, i].set_title(f'Exponential Distribution - Sample Size {sample_size}') # Binomial distribution sampling binomial_means = sample_means(binomial_population, sample_size, num_samples) sns.histplot(binomial_means, bins=30, kde=True, ax=axes[2, i]) axes[2, i].set_title(f'Binomial Distribution - Sample Size {sample_size}') plt.tight_layout() plt.show()","title":"Function to generate and visualize sampling distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#run-the-simulation","text":"central_limit_theorem()","title":"Run the simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}